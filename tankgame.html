<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tank Duel</title>
    <style>
        body { text-align: center; overflow: hidden; margin: 0; }
        canvas { background: #222; display: block; margin: auto; }
        .win-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 50px;
            font-weight: bold;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="winMessage" class="win-message"></div>
    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

class Tank {
    constructor(x, y, color, keys) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.width = 40;
        this.height = 40;
        this.angle = 0;
        this.speed = 3;
        this.keys = keys;
        this.bullets = [];
        this.health = 3;
        this.ammo = 5;
        this.shootCooldown = false;
        this.isReloading = false;
        this.reloadTimer = 0;
        this.recoil = 0; // New property for recoil
    }

    draw() {
        // Draw the tank
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
        ctx.fillStyle = "black";
        
        // Apply recoil to the barrel's x-position
        const barrelX = this.width / 2.5 - 5 + this.recoil;
        ctx.fillRect(barrelX, -5, 25, 10);
        
        ctx.restore();

        // Draw the health bar
        ctx.fillStyle = "red";
        ctx.fillRect(this.x - 20, this.y - 50, 40, 5);
        ctx.fillStyle = "green";
        ctx.fillRect(this.x - 20, this.y - 50, (this.health / 3) * 40, 5);

        // Draw the ammo bar
        ctx.fillStyle = "gray";
        ctx.fillRect(this.x - 20, this.y + 40, 40, 5);  // Background of ammo bar
        ctx.fillStyle = "blue";
        ctx.fillRect(this.x - 20, this.y + 40, (this.ammo / 5) * 40, 5);  // Ammo bar

        // Show reload timer if reloading
        if (this.isReloading) {
            ctx.fillStyle = "white";
            ctx.font = "16px Arial";  // Smaller text
            ctx.fillText(`Reloading: ${Math.ceil(this.reloadTimer)}s`, this.x - 20, this.y + 40);
        }
    }

    move(keysPressed, obstacles) {
        let newX = this.x;
        let newY = this.y;
        if (keysPressed[this.keys.left]) this.angle -= 0.05;
        if (keysPressed[this.keys.right]) this.angle += 0.05;
        if (keysPressed[this.keys.up]) {
            newX += Math.cos(this.angle) * this.speed;
            newY += Math.sin(this.angle) * this.speed;
        }
        if (keysPressed[this.keys.down]) {
            newX -= Math.cos(this.angle) * this.speed;
            newY -= Math.sin(this.angle) * this.speed;
        }
        if (!obstacles.some(obstacle => obstacle.collides({ x: newX, y: newY, width: this.width, height: this.height }))) {
            this.x = newX;
            this.y = newY;
        }
    }

    shoot() {
        if (this.ammo > 0 && !this.shootCooldown && !this.isReloading) {
            this.bullets.push({ x: this.x, y: this.y, angle: this.angle, speed: 16 });
            this.ammo--;
            this.shootCooldown = true;
            
            // Apply recoil when shot is fired
            this.recoil = -5;  // Move the barrel back

            // Return recoil to normal after 150ms
            setTimeout(() => {
                this.recoil = 0;
            }, 150);

            setTimeout(() => this.shootCooldown = false, 1000);
        } else if (this.ammo === 0 && !this.isReloading) {
            // Start reloading if ammo is 0
            this.isReloading = true;
            this.reloadTimer = 10; // 10 seconds reload time
        }
    }

    updateBullets(enemy, obstacles) {
        this.bullets = this.bullets.filter(bullet => {
            bullet.x += Math.cos(bullet.angle) * bullet.speed;
            bullet.y += Math.sin(bullet.angle) * bullet.speed;
            ctx.fillStyle = "yellow";
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
            ctx.fill();
            
            if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
                return false;
            }
            if (obstacles.some(obstacle => obstacle.collides({ x: bullet.x, y: bullet.y, width: 5, height: 5 }))) {
                return false;
            }
            if (Math.hypot(bullet.x - enemy.x, bullet.y - enemy.y) < 20) {
                enemy.health--;
                if (enemy.health <= 0) {
                    document.getElementById("winMessage").textContent = `${this.color.toUpperCase()} WINS!`;
                    document.getElementById("winMessage").style.display = "block";
                    gameRunning = false;
                }
                return false;
            }
            return true;
        });
    }

    updateReloading() {
        if (this.isReloading) {
            this.reloadTimer -= 0.05; // Decrease by 0.1 second each frame
            if (this.reloadTimer <= 0) {
                this.ammo = 5; // Fully reload ammo
                this.isReloading = false;
            }
        }
    }
}






        class Obstacle {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }
            draw() {
                ctx.fillStyle = "gray";
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
            collides(entity) {
                return (
                    entity.x > this.x && entity.x < this.x + this.width &&
                    entity.y > this.y && entity.y < this.y + this.height
                );
            }
        }

        function randomObstacles() {
            let obstacles = [];
            for (let i = 0; i < 3; i++) {
                let x, y, valid;
                do {
                    x = Math.random() * (canvas.width - 100);
                    y = Math.random() * (canvas.height - 300);
                    valid = ![tank1, tank2].some(tank => Math.hypot(x - tank.x, y - tank.y) < 100);
                } while (!valid);
                obstacles.push(new Obstacle(x, y, 100, 300));
            }
            return obstacles;
        }

        const keysPressed = {};
        const tank1 = new Tank(200, 350, "blue", { up: "w", down: "s", left: "a", right: "d", shoot: " " });
        const tank2 = new Tank(1000, 350, "red", { up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", shoot: "Enter" });
        let obstacles = randomObstacles();

        let gameRunning = true;

        window.addEventListener("keydown", (e) => {
            keysPressed[e.key] = true;
            if (gameRunning) {
                if (e.key === tank1.keys.shoot) tank1.shoot();
                if (e.key === tank2.keys.shoot) tank2.shoot();
            }
        });
        window.addEventListener("keyup", (e) => { delete keysPressed[e.key]; });

        function gameLoop() {
            if (!gameRunning) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            obstacles.forEach(obstacle => obstacle.draw());
            tank1.move(keysPressed, obstacles);
            tank2.move(keysPressed, obstacles);
            tank1.updateBullets(tank2, obstacles);
            tank2.updateBullets(tank1, obstacles);
            tank1.updateReloading();
            tank2.updateReloading();
            tank1.draw();
            tank2.draw();
            requestAnimationFrame(gameLoop);
        }
        gameLoop();
    </script>
</body>
</html>
